//	小易来到了一条石板路前，每块石板上从1挨着编号为：1、2、3.......
//	这条石板路要根据特殊的规则才能前进：对于小易当前所在的编号为K的 石板，
//	小易单次只能往前跳K的一个约数(不含1和K)步，即跳到K + X(X为K的一个非1和本身的约数)的位置。 
//	小易当前处在编号为N的石板，他想跳到编号恰好为M的石板去，小易想知道最少需要跳跃几次可以到达。
//	例如：
//	N = 4，M = 24：
//	4->6->8->12->18->24
//	于是小易最少需要跳跃5次，就可以从4号石板跳到24号石板
//	输入描述 :
//	输入为一行，有两个整数N，M，以空格隔开。
//	(4 ≤ N ≤ 100000)
//	(N ≤ M ≤ 100000)
//	
//	输出描述 :
//		 输出小易最少需要跳跃的步数, 如果不能到达输出 - 1
#include<iostream>
#include<cmath>
using namespace std;

//获取约数
int* get(int n,int *num)
{
	int* arr = new int[n];
	int* arr1 = new int[n / 2];
	int j = 0,k = 0;
	for (int i = n / 2; i > 1; i--)
	{
		if (n%i == 0)
			arr[j++] = i;
	}
	*num = j;
	return arr;
}

int step(int n, int m,int count)
{
	if (n >= m)
	{
		if (n == m)
			return count;
		return -1;
	}
	int num;
	int res;
	int *arr = get(n,&num);
	for (int i = 0; i < num; i++)
	{
		res = step(arr[i] + n, m, count + 1);
		if (res > 0)
			return res;
	}
	return -1;
}
int main()
{
	int N, M;
	cin >> N >> M;

	cout << step(N, M, 0) << endl;
	
	system("pause");
	return 0;
}
/*
答案错误:您提交的程序没有通过所有的测试用例
case通过率为80.00%

测试用例:
676 12948

对应输出应该为:
10
你的输出为:
13
*/