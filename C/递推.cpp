//从原点出发，一步只能向右走、向上走或向左走。恰好走N步且不经过已走的点共有多少种走法 
#include<stdio.h>
int main()
{
	int i,n,f[3];
	f[0]=2,f[1]=1,f[2]=3;					
	scanf("%d",&n);
	if(n==1)
	printf("%d",3);
	else
	{
		for(i=2;i<=n;i++)//从这开始就是  递推 
		{
			f[0]=f[0]+f[1]*2;		//根据下面推到出来的公式法 f(n) = f(n-2) +2*f(n-1) 	f(0)就是第n步可以选择的走法 
			f[1]=f[2];				
			f[2]=f[0]+f[1];			
		}
		printf("%d",f[2]);
	}
	return 0;
}
//对于N=3时，有4个点D、E、F、G可以走出2种不同走法的，
//这4个点又是怎么得到的呢？它与N值有什么联系呢？
// 实际上我们在解决了上一个问题的时候，这个问题就变得相当容易了，
//  f（n-1）减掉刚才有3种走法的点，剩下的点不就是只有2种走法了吗？
//  即f（n-1）-f（n-2）。
//
//    c. 得出f（n）的一般关系式
//
//		****************************f(n)=3*f(n-2)+2*(f(n-1)-f(n-2) ) (n>=3)******************************** 
//
//化简：
//
//f(n)=2*f(n-1)+f(n-2) (n>=3)
//
//      有一点需要补充的就是，任何递推题，都会有临界条件。
//	  当N=1时，f(n)=3;,当N=2时，f(n)=7,这些都可以看成是临界条件。
//	  只有当N>=3时，即上上步存在的情况下，就可以得出f(n)的一般通式：************f(n)=2*f(n-1)+f(n-2)******************** 
