/*
如果一个自然数N的K进制表示中任意的相邻的两位都不是相邻的数字，那么我们就说这个数是K好数。
求L位K进制数中K好数的数目。
例如K = 4，L = 2的时候，
所有K好数为11、13、20、22、30、31、33 共7个。由于这个数目很大，请你输出它对1000000007取模后的值。

输入格式
输入包含两个正整数，K和L。

输出格式
输出一个整数，表示答案对1000000007取模后的值。 
样例输入
4 2 
样例输出
7 
简单DP，dp[i][j],其中i代表的是数字有几位，j代表首位放j的情况有几种
*/
/*先算出K 进制 一位数 0--9开头 每个开头的个数，再算出，0--9 开头 每个开头的个数，再算出三位--------以此类推*/ 
#include<iostream>
using namespace std;
long long sum=0,dp[105][105];//行 代表  位数   列代表 0-9开头的数中  有几个K好数  （还没弄明白为什么要放在全局里面，反正放在局部数据大了就不行了） 
int main()
{
	int x,i,j,k,l;
	cin>>k>>l;//k进制，l位 
	
	for(i=0;i<k;i++)//必须从0开始 不是说为什么最高位不能从 0 开始么？ 答：关键是如果有两位数、0就不是最高位了  比如 130
	dp[1][i] = 1;//一位数 的 k 进制     每一位数开头的  都只有一个 K 好数
	
	for(i=2;i<=l;i++)//从两位数开始  直到 l 位数
		for(j=0;j<k;j++)//i位数 j 开头的数  注意 j 现在是最高位，可是最终不一定是最高位，到时候输出不输出 最高位为 0 的数  即可 
			for(x=0;x<k;x++)//用于遍历 上一位  从 0 - 9 开头的数 
				if(j!=x+1 && j!=x-1)//第 i 位的 j 开头的数  不能和 第 i - 1 位的 开头相邻
				{
					dp[i][j] += dp[i-1][x];
					dp[i][j] %=  1000000007;
				 }
				 
	for(i=1;i<k;i++)//为什么从1开始？ 答：最高位不能为0 
	{
		sum += dp[l][i];
		sum %= 1000000007;
	}
	cout<<sum<<endl;
 	return 0;
 } 
/*
 *还是第一次接触DP   不过 我的感觉就是 简单的动态规划 
 */
