/*题目很简单，给出N个数字，不改变它们的相对位置，在中间加入K个乘号和N-K-1个加号，（括号随便加）使最终结果尽量大。
因为乘号和加号一共就是N-1个了，所以恰好每两个相邻数字之间都有一个符号。例如：
　　N=5，K=2，5个数字分别为1、2、3、4、5，可以加成：
　　1*2*(3+4+5)=24
　　1*(2+3)*(4+5)=45
　　(1*2+3)*(4+5)=45	*/ 
#include<stdio.h>
int a[120],sum[120];
int f[120][120];
int max(int a,int b)
{
	return a>b?a:b;
}
int main()
{
    int n,k,i,j,b;
    sum[0]=0;
    scanf("%d%d",&n,&k);
    for(i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        sum[i]=sum[i-1]+a[i];
    }

// 以 n 为列  k 为行 
    for(i=1;i<=n;i++)	//先给出第一列数据 
	f[i][0]=sum[i];
	
    for( i=2;i<=n;i++)	//依次给出行数据，数据为2个，3个，4个，5个等 
    {
      for( j=1;j<=k;j++)// 依次给出列数据，乘号为1个，2个，3个，4个，5个等 
      {
          for( b=1;b<i;b++)
          {
              int s=sum[i]-sum[b];	// 新增数据重新规划 
              f[i][j]//求出这一坐标最大值 
			  =max(f[b][j-1]/*旧数据与新数据进行合并*/
			  *s,f[i][j]);
          }
      }
    }
    //f[i][0]是前i个相邻数之间都只有加法没有乘法 		的乘法（乘1）集合 
	//f[i][1]是前i个邻数之间只包含一个乘法 	 			的乘法集合
	//f[i][2]是前i个邻数之间包含两个乘法				的乘法集合
	
	//sum[i] - sum[1] == 所有数之和 减去 前面1个数
	//sum[i] - sum[2] == 所有数之和 减去 前面2个数
	//sum[i] - sum[3] == 所有数之和 减去 前面3个数
	
	//f[1][j] * (sum[i] - sum[1]) == 前1个数  和  后面  相加后的数  再相乘 
    //f[2][j] * (sum[i] - sum[1]) == 前2个数  和  后面  相加后的数  再相乘 
    //f[3][j] * (sum[i] - sum[1]) == 前3个数  和  后面  相加后的数  再相乘 (至于前面三个数有几个乘号，取决于f[i][j] 中 j 的值) 
   	for( i=0;i<=n;i++)
	{
	for( j=0;j<=k;j++)
	printf("%d\t",f[i][j]);
	printf("\n");
	}
	
    printf("%d",f[n][k]);
    return 0;
}

