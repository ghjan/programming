#include <stdio.h>
int n,m;
int FangAn(int m,int n);
int dong(int a,int b);
int main(int argc, const char * argv[])
{
    int s,s1;
    scanf("%d%d",&m,&n);
    s=FangAn(m, n);
    s1=dong(0,0);
    printf("%d\n%d",s,s1);
    
    return 0;
}
int FangAn(int m,int n)
{
    if (m<n)
    {
        return 0;
    }
    if (n==0)
    {
        return 1;							//  当这种排列成立就返回1  因为最后算的是一共有几种 排列 
    }
    return FangAn(m-1, n)+FangAn(m, n-1);
}
/*
m个人来还鞋，n个人来借鞋、
不能用全排列，然后筛选，最后再消序。。。这样做可是可以  但是当数据稍微大一点。。计算时间相当的长。。早就超出题目所给的时间

第一眼看到这个递归的时候也是很迷茫   自己当时想了很久   也是用上面思路来实现。。。但是耗费了我很多时间。 。而且最终代码也只给了我20分

所以看到这么简洁的代码  把我惊呆了

递归很费时，很占内存和CPU,也很难理解。但是代码实在是很简单

下面是我自己的总结：
1.这是一个无序的排序。不能用常规的思路来解
2.我对这个代码的解答是：  递归都是和正常思路相反的   
 我们可以先从最后一位排列     fangan(  ) 这个函数就是每次把 换鞋，和，借鞋。的人减一   也就是排到最后一个位子
 m-1,n  代表了最后一位是还鞋的  所以m-1 
 如果排了最后一个位置导致前面的 N > M  (借鞋的还鞋的还多)那就返回0  就不起作用  不算做一种排序 
 fan(m-1,n)+fan(m,n-1)的最重要一个作用就是  他能把从最后一个位置 到 倒数第二个 倒数第三个位置
 （借鞋 还鞋 所有的排列都解决。。不是 m -1 就是 n - 1。不是借鞋就是还鞋在最后一个位置）。每次最后一个位置固定了之后 都判断一下前面是否 n>m  
  所有排序都实现了  
*/
int dong(int a,int b)
{
	if(m<n)					// 首先得保证还的人比借的人多 
	return 0;
	if(a<b)					// 一旦出现 借的人比 还的人多 这条路就不用走了 返回0 
	return 0;
	if(a==m||b==n)	// 任何一方走完 如果都没有出现问题  无论是 借的人还有（前提保证了还的人比借的人多，多出来借鞋人直接全部排在后面） 还的人还有也是直接排在后面 
	return 1;
	return dong(a+1,b)+dong(a,b+1);
 } 
 // 上面这段代码我是用正方向的 思想写出来的  适合一般人的思想
 //   其实核心思想就是  借与不借  还与不还   的思想 
