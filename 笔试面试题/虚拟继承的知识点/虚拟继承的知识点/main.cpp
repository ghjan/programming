#include <iostream>
using namespace std;

void test1();
void test2();
void test3();
void test4();
void test5();
void test6();
void test7();
void test8();
/*
因为每个存在虚函数的类都要有一个4字节的指针指向自己的虚函数表，
所以每种情况的类a所占的字节数应该是没有什么问题的，那么类b的字节数怎么算呢？
看“第一种”和“第三种”情况采用的是虚继承，那么这时候就要有这样的一个指针vptr_b_a，这个指针叫虚类指针，
也是四个字节；还要包括类a的字节数，所以类b的字节数就求出来了。
而“第二种”和“第四种”情况则不包括vptr_b_a这个指针，这回应该木有问题了吧。
*/
/*
★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
在虚继承时，派生类与基类不共享虚函数表指针，所以派生类会在基类的基础上增加一个虚函数表指针和虚基类指针。
如果是多层虚继承，每一个派生类都会有自己的虚基类指针，虚基类指针是永远不会共享的。
如果不是虚继承，则派生类和基类共享虚函数表指针，且派生类里不会有虚基类指针。
在g++中，即使虚继承，派生类也会和基类共享虚函数指针，有点怪异啊。
★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
*/
int main()
{
	test1();
	test2();
	test3();
	test4();
	test5();
	test6();
	test7();

	system("pause");
}


